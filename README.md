# 457-Proj3-Security
Multi-client chat program encrypted via AES in CBC mode

## Security Overview
The purpose of this project was to demonstrate an understanding of multi-client/server interactions, and OpenSSL encryption to add a layer of privacy to messages sent over TCP.

This program requires the server to be started first. After that, up to 10 clients may connect to the server. From there, each client can communicate directly with the server to have the server broadcast a message to all connected clients, send a private message to one client, receive a list of all connected clients, or kick another client (requires a password). Upon connection, each client generates a random symmetric key which is encrypted with the public RSA key and sent to the server. The server decrypts the symmetric key with the private RSA key, and records it along with the file descriptor of the client’s socket, which is used as the client’s ID. A random initialization vector is generated by the server of the client for each message that is sent.

## Structures
The server maintains an array of keys (symmetric keys) and an array of socket file descriptors used as the unique ID of each client. When trying to determine which key to use for encryption, the server must iterate through the list of file descriptors, get the index of the file descriptor matching the socket the message was received on, then use that index to get the key for decryption.

## Major Challenge
Size of Messages: there were some inconsistencies in using sizeof vs strlen for the length parameters in encryption and sending/receiving. I ended up switching sending and receiving to sizeof, and making sure all the char arrays were the same size on both the client and server. It was causing some issues where a string was sent that was not the length of the desired reception by the server, and part of the next message would still be received by that first recv call. Switching to sizeof wastes packet space by sending garbage, but the response is then handled as a string so the null terminator in the message let me handle displaying the message regardless. However, to prevent the decryption function from running over the entire array including the garbage after the null terminator, I had to pass the exact length of the encrypted messages in the unencrypted status message beforehand (also used to pass the random initialization vector).
